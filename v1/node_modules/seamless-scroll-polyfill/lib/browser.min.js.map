{"version":3,"file":"browser.min.js","sources":["../src/common.ts","../src/scroll-step.ts","../src/scroll.ts","../src/scroll-end-event.ts","../src/scrollIntoView.ts","../src/scroll.polyfill.ts","../src/scrollIntoView.polyfill.ts","../src/polyfill.ts"],"sourcesContent":["import type { IScrollConfig } from \"./scroll-step.js\";\n\nexport const checkBehavior = (behavior?: string): behavior is undefined | ScrollBehavior => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\n\nexport function elementScrollXY(this: Element, x: number, y: number): void {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\n\nexport const failedExecute = (method: string, object: string, reason = \"cannot convert to dictionary.\"): string =>\n    `Failed to execute '${method}' on '${object}': ${reason}`;\n\nexport const failedExecuteInvalidEnumValue = (method: string, object: string, value: string): string =>\n    failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n\ninterface BackupMethod {\n    <K extends keyof Element>(proto: Element, method: K): Element[K] | undefined;\n    <K extends keyof Element>(proto: Element, method: K, fallback: unknown): Element[K];\n    <K extends keyof Window>(proto: Window, method: K): Window[K] | undefined;\n    <K extends keyof Window>(proto: Window, method: K, fallback: unknown): Window[K];\n}\n\n/* eslint-disable */\nexport const backupMethod: BackupMethod = (proto: any, method: string, fallback?: unknown) => {\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n\n    if (!proto[backup] && proto[method] && !proto[method]?.__isPolyfill) {\n        proto[backup] = proto[method];\n    }\n\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\n\nexport const isObject = (value: unknown): boolean => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\n\nexport const isScrollBehaviorSupported = (config?: IScrollConfig): boolean =>\n    \"scrollBehavior\" in window.document.documentElement.style && config?.forcePolyfill !== true;\n\nexport const markPolyfill = (method: () => void): void => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\n\ntype Prototype = typeof HTMLElement.prototype | typeof SVGElement.prototype | typeof Element.prototype;\n\nexport const modifyPrototypes = <T extends \"scroll\" | \"scrollTo\" | \"scrollBy\" | \"scrollIntoView\">(\n    prop: T,\n    func: Prototype[T],\n): void => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nexport const scrollingElement = (element: Element): Element =>\n    element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n","export interface IScrollConfig {\n    readonly duration?: number;\n    readonly forcePolyfill?: boolean;\n    readonly timingFunc?: (k: number) => number;\n}\n\nexport interface IContext extends IScrollConfig {\n    readonly timeStamp: number;\n    readonly startX: number;\n    readonly startY: number;\n    readonly targetX: number;\n    readonly targetY: number;\n    readonly method: (x: number, y: number) => void;\n    readonly callback: () => void;\n    rafId: number;\n}\n\nconst ease = (k: number) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n\n/* eslint-disable */\nexport function now(): number {\n    let fn: () => number;\n    if (window.performance?.now) {\n        fn = () => window.performance.now();\n    } else {\n        fn = () => window.Date.now();\n    }\n\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\n\nconst DURATION = 500;\n\nexport const step = (context: IContext): void => {\n    const currentTime = now();\n\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n\n    context.method(currentX, currentY);\n\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n","import {\n    backupMethod,\n    checkBehavior,\n    elementScrollXY,\n    failedExecute,\n    failedExecuteInvalidEnumValue,\n    isObject,\n    scrollingElement,\n} from \"./common.js\";\nimport { scrollEndEvent } from \"./scroll-end-event.js\";\nimport type { IContext, IScrollConfig } from \"./scroll-step.js\";\nimport { now, step } from \"./scroll-step.js\";\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value: unknown): number => {\n    if (!isFinite(value as number)) {\n        return 0;\n    }\n    return Number(value);\n};\n\nconst isConnected = (node: Node) => {\n    return (\n        node.isConnected ??\n        (!node.ownerDocument ||\n            // eslint-disable-next-line no-bitwise\n            !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1))\n    );\n};\n\nconst scrollWithOptions = (element: Element, options: Readonly<ScrollToOptions>, config?: IScrollConfig): void => {\n    if (!isConnected(element)) {\n        return;\n    }\n\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n\n    const targetX = nonFinite(options.left ?? startX);\n    const targetY = nonFinite(options.top ?? startY);\n\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element) as Element, \"scroll\", fallback).bind(element);\n\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n\n    const callback = () => {\n        removeEventListener();\n        const isDocument = element.nodeType === /** Node.DOCUMENT_NODE */ 9;\n        element.dispatchEvent(scrollEndEvent(isDocument));\n    };\n\n    const context: IContext = {\n        ...config,\n        timeStamp: now(),\n        startX,\n        startY,\n        targetX,\n        targetY,\n        rafId: 0,\n        method,\n        callback,\n    };\n\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n\n    step(context);\n};\n\nconst isWindow = (obj: unknown): obj is Window => (obj as Window).window === obj;\n\ntype ScrollMethod<T extends Element | typeof window> = (\n    target: T,\n    scrollOptions?: ScrollToOptions,\n    config?: IScrollConfig,\n) => void;\n\nconst createScroll =\n    <T extends Element | typeof window>(scrollName: \"scroll\" | \"scrollTo\" | \"scrollBy\"): ScrollMethod<T> =>\n    (target, scrollOptions, config): void => {\n        const [element, scrollType]: [Element, \"Window\" | \"Element\"] = isWindow(target)\n            ? [scrollingElement(target.document.documentElement), \"Window\"]\n            : [target, \"Element\"];\n\n        const options = scrollOptions ?? {};\n\n        if (!isObject(options)) {\n            throw new TypeError(failedExecute(scrollName, scrollType));\n        }\n\n        if (!checkBehavior(options.behavior)) {\n            throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n        }\n\n        if (scrollName === \"scrollBy\") {\n            options.left = nonFinite(options.left) + element.scrollLeft;\n            options.top = nonFinite(options.top) + element.scrollTop;\n        }\n\n        scrollWithOptions(element, options, config);\n    };\n\nexport const scroll = /* #__PURE__ */ createScroll(\"scroll\");\nexport const scrollTo = /* #__PURE__ */ createScroll(\"scrollTo\");\nexport const scrollBy = /* #__PURE__ */ createScroll(\"scrollBy\");\n\nexport const elementScroll = scroll as ScrollMethod<Element>;\nexport const elementScrollTo = scrollTo as ScrollMethod<Element>;\nexport const elementScrollBy = scrollBy as ScrollMethod<Element>;\n\nexport const windowScroll = scroll as ScrollMethod<typeof window>;\nexport const windowScrollTo = scrollTo as ScrollMethod<typeof window>;\nexport const windowScrollBy = scrollBy as ScrollMethod<typeof window>;\n","export function scrollEndEvent(bubbles: boolean): Event {\n    if (typeof Event === \"function\") {\n        return new Event(\"scrollend\", {\n            bubbles,\n            cancelable: false,\n        });\n    }\n\n    const event = document.createEvent(\"Event\");\n    event.initEvent(\"scrollend\", bubbles, false);\n\n    return event;\n}\n","/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport { elementScroll } from \"./scroll.js\";\n\nconst enum ScrollAlignment {\n    ToEdgeIfNeeded,\n    CenterAlways,\n    LeftOrTop,\n    RightOrBottom,\n}\n\nconst enum WritingMode {\n    HorizontalTb,\n    VerticalRl,\n    VerticalLr,\n    SidewaysRl,\n    SidewaysLr,\n}\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode: string): WritingMode => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return WritingMode.HorizontalTb;\n\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return WritingMode.VerticalRl;\n\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return WritingMode.VerticalLr;\n\n        case \"sideways-rl\":\n            return WritingMode.SidewaysRl;\n\n        case \"sideways-lr\":\n            return WritingMode.SidewaysLr;\n    }\n\n    return WritingMode.HorizontalTb;\n};\n\ntype Tuple2<T> = [T, T];\n\nconst calcPhysicalAxis = <T>(writingMode: WritingMode, isLTR: boolean, hPos: T, vPos: T): [number, T, T] => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n\n    const enum OP {\n        ReverseHorizontal = 0b01,\n        ReverseVertical = 0b10,\n    }\n\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= OP.ReverseVertical;\n    }\n\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case WritingMode.HorizontalTb:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case WritingMode.VerticalRl:\n        case WritingMode.SidewaysRl:\n            //  reverse horizontal\n            layout ^= OP.ReverseHorizontal;\n            break;\n\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case WritingMode.SidewaysLr:\n            // reverse vertical\n            layout ^= OP.ReverseVertical;\n            break;\n    }\n\n    return [layout, hPos, vPos];\n};\n\nconst isXReversed = (computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    const layout = calcPhysicalAxis(\n        normalizeWritingMode(computedStyle.writingMode),\n        computedStyle.direction !== \"rtl\",\n        undefined,\n        undefined,\n    )[0];\n    return (layout & 1) === 1;\n};\n\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (\n    options: Readonly<ScrollIntoViewOptions>,\n    writingMode: WritingMode,\n    isLTR: boolean,\n): Tuple2<ScrollAlignment> => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(\n        writingMode,\n        isLTR,\n        options.block || \"start\",\n        options.inline || \"nearest\",\n    );\n\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return ScrollAlignment.CenterAlways;\n            case \"nearest\":\n                return ScrollAlignment.ToEdgeIfNeeded;\n\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? ScrollAlignment.LeftOrTop : ScrollAlignment.RightOrBottom;\n            }\n        }\n    }) as Tuple2<ScrollAlignment>;\n};\n\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (\n    align: ScrollAlignment,\n    scrollingEdgeStart: number,\n    scrollingEdgeEnd: number,\n    scrollingSize: number,\n    elementEdgeStart: number,\n    elementEdgeEnd: number,\n    elementSize: number,\n): Exclude<ScrollAlignment, ScrollAlignment.ToEdgeIfNeeded> | null => {\n    if (align !== ScrollAlignment.ToEdgeIfNeeded) {\n        return align;\n    }\n\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n    ) {\n        return null;\n    }\n\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n    ) {\n        return ScrollAlignment.LeftOrTop;\n    }\n\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if (\n        (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n    ) {\n        return ScrollAlignment.RightOrBottom;\n    }\n\n    return null;\n};\n\nconst canOverflow = (overflow: string | null): boolean => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = (element: Element): Element | null => {\n    try {\n        return element.ownerDocument.defaultView?.frameElement || null;\n    } catch {\n        return null;\n    }\n};\n\nconst isScrollable = (element: Element, computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (\n            canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element)\n        );\n    }\n\n    return false;\n};\n\nconst parentElement = (element: Element): Element | null => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return (pNode as ShadowRoot).host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n\n    return pElement;\n};\n\nconst clamp = (value: number, min: number, max: number): number => {\n    if (value < min) {\n        return min;\n    }\n\n    if (value > max) {\n        return max;\n    }\n\n    return value;\n};\n\nconst getSupportedScrollMarginProperty = (\n    ownerDocument: Document,\n): \"scroll-margin\" | \"scroll-snap-margin\" | undefined => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return ([\"scroll-margin\", \"scroll-snap-margin\"] as const).filter(\n        (property) => property in ownerDocument.documentElement.style,\n    )[0];\n};\n\nconst getElementScrollSnapArea = (\n    element: Element,\n    elementRect: Readonly<DOMRect>,\n    computedStyle: Readonly<CSSStyleDeclaration>,\n): [top: number, right: number, bottom: number, left: number] => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n\n    const scrollMarginValue = (edge: \"top\" | \"right\" | \"bottom\" | \"left\"): number => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\n\nconst calcAlignEdge = (align: ScrollAlignment, start: number, end: number): number => {\n    switch (align) {\n        case ScrollAlignment.CenterAlways:\n            return (start + end) / 2;\n\n        case ScrollAlignment.RightOrBottom:\n            return end;\n\n        case ScrollAlignment.LeftOrTop:\n        case ScrollAlignment.ToEdgeIfNeeded:\n            return start;\n    }\n};\n\nconst getFrameViewport = (frame: Element, frameRect: Readonly<DOMRect>) => {\n    const visualViewport = frame.ownerDocument.defaultView?.visualViewport;\n    const [x, y, width, height] =\n        frame === scrollingElement(frame)\n            ? [0, 0, visualViewport?.width ?? frame.clientWidth, visualViewport?.height ?? frame.clientHeight]\n            : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n\n    return [top, right, bottom, left] as const;\n};\n\nconst computeScrollIntoView = (element: Element, options: ScrollIntoViewOptions): [Element, ScrollToOptions][] => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions: [Element, ScrollToOptions][] = [];\n\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n\n    if (!ownerWindow) {\n        return actions;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n\n    const writingMode = normalizeWritingMode(\n        computedStyle.writingMode ||\n            computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n            computedStyle.getPropertyValue(\"-ms-writing-mode\"),\n    );\n\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n\n        const frameRect = frame.getBoundingClientRect();\n\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n\n        const diffX =\n            eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY =\n            eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n\n    return actions;\n};\n\nexport const scrollIntoView = (\n    element: Element,\n    scrollIntoViewOptions?: ScrollIntoViewOptions,\n    config?: IScrollConfig,\n): void => {\n    const options = scrollIntoViewOptions || {};\n\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n\n    const actions = computeScrollIntoView(element, options);\n\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\n\nexport const elementScrollIntoView = scrollIntoView;\n","import { backupMethod, isScrollBehaviorSupported, markPolyfill, modifyPrototypes } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport { scroll, scrollBy, scrollTo } from \"./scroll.js\";\n\ntype ScrollName = \"scroll\" | \"scrollTo\" | \"scrollBy\";\n\ntype Patch = <T extends ScrollName>(prop: T, func: (Element | typeof window)[T]) => void;\n\nconst createPolyfill =\n    (scrollName: ScrollName, patch: Patch) =>\n    (config?: IScrollConfig): void => {\n        if (isScrollBehaviorSupported(config)) {\n            return;\n        }\n\n        const scrollMethod = {\n            scroll,\n            scrollTo,\n            scrollBy,\n        }[scrollName];\n\n        patch(scrollName, function (this: Element | typeof window): void {\n            const args = arguments;\n            if (arguments.length === 1) {\n                scrollMethod(this, args[0] as ScrollToOptions, config);\n                return;\n            }\n\n            const left = args[0] as number;\n            const top = args[1] as number;\n            scrollMethod(this, { left, top });\n        });\n    };\n\nexport const elementScrollPolyfill = /* #__PURE__ */ createPolyfill(\"scroll\", modifyPrototypes);\nexport const elementScrollToPolyfill = /* #__PURE__ */ createPolyfill(\"scrollTo\", modifyPrototypes);\nexport const elementScrollByPolyfill = /* #__PURE__ */ createPolyfill(\"scrollBy\", modifyPrototypes);\n\nconst modifyWindow = <T extends \"scroll\" | \"scrollTo\" | \"scrollBy\">(prop: T, func: (typeof window)[T]): void => {\n    markPolyfill(func);\n    backupMethod(window, prop);\n    window[prop] = func;\n};\n\nexport const windowScrollPolyfill = /* #__PURE__ */ createPolyfill(\"scroll\", modifyWindow);\nexport const windowScrollToPolyfill = /* #__PURE__ */ createPolyfill(\"scrollTo\", modifyWindow);\nexport const windowScrollByPolyfill = /* #__PURE__ */ createPolyfill(\"scrollBy\", modifyWindow);\n","import { backupMethod, isObject, isScrollBehaviorSupported, modifyPrototypes } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport { elementScrollIntoView } from \"./scrollIntoView.js\";\n\nfunction elementScrollIntoViewBoolean(this: Element, alignToTop?: unknown) {\n    elementScrollIntoView(this, {\n        block: alignToTop ?? true ? \"start\" : \"end\",\n        inline: \"nearest\",\n    });\n}\n\nexport const elementScrollIntoViewPolyfill = (config?: IScrollConfig): void => {\n    if (isScrollBehaviorSupported(config)) {\n        return;\n    }\n\n    const originalFunc = backupMethod(window.HTMLElement.prototype, \"scrollIntoView\", elementScrollIntoViewBoolean);\n\n    modifyPrototypes(\"scrollIntoView\", function scrollIntoView(this: Element): void {\n        const args = arguments;\n        const options = args[0] as unknown;\n\n        if (args.length === 1 && isObject(options)) {\n            elementScrollIntoView(this, options as ScrollIntoViewOptions, config);\n            return;\n        }\n\n        originalFunc.apply(this, args as never);\n    });\n};\n","import { isScrollBehaviorSupported } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport {\n    elementScrollByPolyfill,\n    elementScrollPolyfill,\n    elementScrollToPolyfill,\n    windowScrollByPolyfill,\n    windowScrollPolyfill,\n    windowScrollToPolyfill,\n} from \"./scroll.polyfill.js\";\nimport { elementScrollIntoViewPolyfill } from \"./scrollIntoView.polyfill.js\";\n\nexport * from \"./scroll.polyfill.js\";\nexport * from \"./scrollIntoView.polyfill.js\";\n\nexport const polyfill = (config?: IScrollConfig): void => {\n    if (isScrollBehaviorSupported(config)) {\n        return;\n    }\n\n    elementScrollPolyfill(config);\n    elementScrollToPolyfill(config);\n    elementScrollByPolyfill(config);\n    elementScrollIntoViewPolyfill(config);\n\n    windowScrollPolyfill(config);\n    windowScrollToPolyfill(config);\n    windowScrollByPolyfill(config);\n};\n"],"names":["checkBehavior","behavior","undefined","elementScrollXY","x","y","this","scrollLeft","scrollTop","failedExecute","method","object","reason","concat","failedExecuteInvalidEnumValue","value","backupMethod","proto","fallback","backup","_a","__isPolyfill","isObject","type","isScrollBehaviorSupported","config","window","document","documentElement","style","forcePolyfill","markPolyfill","Object","defineProperty","modifyPrototypes","prop","func","HTMLElement","prototype","SVGElement","Element","forEach","scrollingElement","element","ownerDocument","ease","k","Math","cos","PI","now","fn","performance","Date","step","context","elapsed","timeStamp","duration","targetX","targetY","callback","timingFunc","currentX","startX","currentY","startY","rafId","requestAnimationFrame","nonFinite","isFinite","Number","scrollWithOptions","options","node","isConnected","compareDocumentPosition","left","_b","top","getPrototypeOf","bind","removeEventListener","cancelScroll","__assign","isDocument","nodeType","dispatchEvent","bubbles","Event","cancelable","event","createEvent","initEvent","scrollEndEvent","cancelAnimationFrame","addEventListener","passive","once","createScroll","scrollName","target","scrollOptions","obj","__read","scrollType","TypeError","scroll","scrollTo","scrollBy","elementScroll","elementScrollTo","elementScrollBy","windowScroll","windowScrollTo","windowScrollBy","normalizeWritingMode","writingMode","calcPhysicalAxis","isLTR","hPos","vPos","layout","isXReversed","computedStyle","direction","mapNearest","align","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","elementEdgeStart","elementEdgeEnd","elementSize","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","parentElement","pNode","parentNode","pElement","host","defaultView","frameElement","getFrameElement","clamp","min","max","calcAlignEdge","start","end","getFrameViewport","frame","frameRect","visualViewport","_d","width","_c","height","clientLeft","clientTop","computeScrollIntoView","actions","ownerWindow","getComputedStyle","block","inline","map","index","toPhysicalAlignment","getPropertyValue","alignH","alignV","elementRect","right","bottom","scrollProperty","filter","property","scrollMarginValue","edge","parseInt","getElementScrollSnapArea","getBoundingClientRect","dX","dY","frameStyle","position","frameTop","frameRight","frameBottom","frameLeft","eAlignH","eAlignV","diffX","diffY","moveX","moveY","push","scrollIntoView","scrollIntoViewOptions","scrollToOptions","elementScrollIntoView","createPolyfill","patch","scrollMethod","args","arguments","length","elementScrollPolyfill","elementScrollToPolyfill","elementScrollByPolyfill","modifyWindow","windowScrollPolyfill","windowScrollToPolyfill","windowScrollByPolyfill","elementScrollIntoViewBoolean","alignToTop","elementScrollIntoViewPolyfill","originalFunc","apply"],"mappings":"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"}